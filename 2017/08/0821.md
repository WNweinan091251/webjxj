# Koa 框架简介

### koa 致力于成为一个更小、更富有表现力、更健壮的 Web 框架.使用 koa 编写 web 应用，通过组合不同的 generator，可以免除重复繁琐的回调函数嵌套，并极大地提升错误处理的效率.

### koa 不在内核方法中绑定任何中间件，它仅仅提供了一个轻量优雅的函数库，使得编写 Web 应用变得得心应手.

## Node 主要用在开发 Web 应用.这决定了使用 Node，往往离不开 Web 应用框架.

## 一、基本用法
- 1.1 架设 HTTP 服务(01)
只要三行代码，就可以用 Koa 架设一个 HTTP 服务.

- 1.2 Context 对象(02)
Koa 提供一个 Context 对象，表示一次对话的上下文（包括 HTTP 请求和 HTTP 回复）.通过加工这个对象，就可以控制返回给用户的内容.
Context.response.body属性就是发送给用户的内容.

- 1.3 HTTP Response 的类型(03)
Koa 默认的返回类型是text/plain，如果想返回其他类型的内容，可以先用ctx.request.accepts判断一下，客户端希望接受什么数据（根据 HTTP Request 的Accept字段），然后使用ctx.response.type指定返回类型.

- 1.4 网页模板(04)
实际开发中，返回给用户的网页往往都写成模板文件.我们可以让 Koa 先读取模板文件，然后将这个模板返回给用户.

## 二、路由
- 2.1 原生路由(05)
网站一般都有多个页面.通过ctx.request.path可以获取用户请求的路径，由此实现简单的路由.

- 2.2 koa-route 模块(06)
原生路由用起来不太方便，我们可以使用封装好的koa-route模块.

- 2.3 静态资源(12)
如果网站提供静态资源（图片、字体、样式表、脚本......），为它们一个个写路由就很麻烦，也没必要.koa-static模块封装了这部分的请求.

- 2.4 重定向(13)
有些场合，服务器需要重定向（redirect）访问请求.比如，用户登陆以后，将他重定向到登陆前的页面.ctx.response.redirect()方法可以发出一个302跳转，将用户导向另一个路由.

## 三、中间件
- 3.1 Logger 功能(07)
Koa 的最大特色，也是最重要的一个设计，就是中间件（middleware）.为了理解中间件，我们先看一下 Logger （打印日志）功能的实现.

- 3.2 中间件的概念(08)
 Logger 功能，可以拆分成一个独立函数

- 3.3 中间件栈(09)
多个中间件会形成一个栈结构（middle stack），以"先进后出"（first-in-last-out）的顺序执行.

- 3.4 异步中间件(10)
如果有异步操作（比如读取数据库），中间件就必须写成 async 函数.

- 3.5 中间件的合成(11)
koa-compose模块可以将多个中间件合成为一个.

## 四、错误处理

- 4.1 500 错误(14)
如果代码运行过程中发生错误，我们需要把错误信息返回给用户.HTTP 协定约定这时要返回500状态码.Koa 提供了ctx.throw()方法，用来抛出错误，ctx.throw(500)就是抛出500错误.

- 4.2 404错误(15)
如果将ctx.response.status设置成404，就相当于ctx.throw(404)，返回404错误.

- 4.3 处理错误的中间件(16)
为了方便处理错误，最好使用try...catch将其捕获.但是，为每个中间件都写try...catch太麻烦，我们可以让最外层的中间件，负责所有中间件的错误处理.

- 4.4 error 事件的监听(17)
运行过程中一旦出错，Koa 会触发一个error事件.监听这个事件，也可以处理错误.

- 4.5 释放 error 事件(18)
需要注意的是，如果错误被try...catch捕获，就不会触发error事件.这时，必须调用ctx.app.emit()，手动释放error事件，才能让监听函数生效.

## 五、Web App 的功能
- 5.1 Cookies(19)
ctx.cookies用来读写 Cookie.

- 5.2 表单(20)
Web 应用离不开处理表单.本质上，表单就是 POST 方法发送到服务器的键值对.koa-body模块可以用来从 POST 请求的数据体里面提取键值对.

- 5.3 文件上传(21)
koa-body模块还可以用来处理文件上传.


### 扩展知识 生成器函数 generator ( ES6 一种异步处理方案)

##### function* 这种声明方式(function关键字后跟一个星号）会定义一个生成器函数 (generator function)，它返回一个  Generator  对象.

生成器函数在执行时能中途退出，后面又能重新进入继续执行.而且在函数内定义的变量的状态都会保留，不受中途退出的影响.

调用一个生成器函数并不会马上执行它里面的语句，而是返回一个这个生成器的迭代器（iterator）对象.当这个迭代器的 next() 方法被首次（后续）调用时，其内的语句会执行到第一个（后续）出现yield表达式的位置为止，该表达式定义了迭代器要返回的值，或者被 yield*委派至另一个生成器函数.next()方法返回一个对象，这个对象包含两个属性：value 和 done，value 属性表示本次 yield 表达式的返回值，done 属性为布尔类型，表示生成器是否已经产出了它最后的值，即生成器函数是否已经返回.

调用 next() 方法时，如果传入了参数，那么这个参数会取代生成器函数中对应执行位置的 yield 表达式（整个表达式被这个值替换）

当在生成器函数中显式 return 时，会导致生成器立即变为完成状态，即调用 next() 方法返回的对象的 done 为 true.如果 return 了一个值，那么这个值会作为下次调用 next() 方法返回的 value 值.

##### 调试器查看
```
function * scqhs(){
 var index =0
 while(index<3)
     yield index++
}
var gen=scqhs();

console.log(gen.next())
console.log(gen.next())
console.log(gen.next())
console.log(gen.next())
```
了解详情访问 mdn

##### 中间键列表
```
https://github.com/koajs/koa/wiki
```