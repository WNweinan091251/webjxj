# vue 组件(下)
##### 先使用≤≥代替```</>```,放置 github 转化. md 文件时,标签运行
## 使用 Slot 分发内容

在使用组件时，我们常常要像这样组合它们：
```
≤app≥
  ≤app-header≥≤/app-header≥
  ≤app-footer≥≤/app-footer≥
≤/app≥
```
注意两点：
- ≤app≥ 组件不知道它的挂载点会有什么内容。挂载点的内容是由≤app≥的父组件决定的。
- ≤app≥ 组件很可能有它自己的模版。


为了让组件可以组合，我们需要一种方式来混合父组件的内容与子组件自己的模板。这个过程被称为 内容分发 。Vue.js 实现了一个内容分发 API ，参照了当前 Web 组件规范草案，使用特殊的 ≤slot≥ 元素作为原始内容的插槽。


### 编译作用域

在深入内容分发 API 之前，我们先明确内容在哪个作用域里编译。假定模板为：
```
≤child-component≥
  {{ message }}
≤/child-component≥
```
message 应该绑定到父组件的数据，还是绑定到子组件的数据？答案是父组件。组件作用域简单地说是：
父组件模板的内容在父组件作用域内编译；子组件模板的内容在子组件作用域内编译。
一个常见错误是试图在父组件模板内将一个指令绑定到子组件的属性/方法：
≤!-- 无效 --≥
```
≤child-component v-show="someChildProperty"≥≤/child-component≥
```
假定 someChildProperty 是子组件的属性，上例不会如预期那样工作。父组件模板不应该知道子组件的状态。
如果要绑定作用域内的指令到一个组件的根节点，你应当在组件自己的模板上做：
```
Vue.component('child-component', {
  // 有效，因为是在正确的作用域内
  template: '≤div v-show="someChildProperty"≥Child≤/div≥',
  data: function () {
    return {
      someChildProperty: true
    }
  }
})
```
类似地，分发内容是在父作用域内编译。

### 单个 Slot

除非子组件模板包含至少一个 ≤slot≥ 插口，否则父组件的内容将会被丢弃。当子组件模板只有一个没有属性的 slot 时，父组件整个内容片段将插入到 slot 所在的 DOM 位置，并替换掉 slot 标签本身。
最初在 ≤slot≥ 标签中的任何内容都被视为备用内容。备用内容在子组件的作用域内编译，并且只有在宿主元素为空，且没有要插入的内容时才显示备用内容。
假定 my-component 组件有下面模板：
```
≤div≥
  ≤h2≥我是子组件的标题≤/h2≥
  ≤slot≥
    只有在没有要分发的内容时才会显示。
  ≤/slot≥
≤/div≥
```
父组件模版：
```
≤div≥
  ≤h1≥我是父组件的标题≤/h1≥
  ≤my-component≥
    ≤p≥这是一些初始内容≤/p≥
    ≤p≥这是更多的初始内容≤/p≥
  ≤/my-component≥
≤/div≥
```
渲染结果：
```
≤div≥
  ≤h1≥我是父组件的标题≤/h1≥
  ≤div≥
    ≤h2≥我是子组件的标题≤/h2≥
    ≤p≥这是一些初始内容≤/p≥
    ≤p≥这是更多的初始内容≤/p≥
  ≤/div≥
≤/div≥
```
### 具名 Slot

≤slot≥ 元素可以用一个特殊的属性 name 来配置如何分发内容。多个 slot 可以有不同的名字。具名 slot 将匹配内容片段中有对应 slot 特性的元素。
仍然可以有一个匿名 slot ，它是默认 slot ，作为找不到匹配的内容片段的备用插槽。如果没有默认的 slot ，这些找不到匹配的内容片段将被抛弃。
例如，假定我们有一个 app-layout 组件，它的模板为：
```
≤div class="container"≥
  ≤header≥
    ≤slot name="header"≥≤/slot≥
  ≤/header≥
  ≤main≥
    ≤slot≥≤/slot≥
  ≤/main≥
  ≤footer≥
    ≤slot name="footer"≥≤/slot≥
  ≤/footer≥
≤/div≥
```
父组件模版：
```
≤app-layout≥
  ≤h1 slot="header"≥这里可能是一个页面标题≤/h1≥
  ≤p≥主要内容的一个段落。≤/p≥
  ≤p≥另一个主要段落。≤/p≥
  ≤p slot="footer"≥这里有一些联系信息≤/p≥
≤/app-layout≥
```
渲染结果为：
```
≤div class="container"≥
  ≤header≥
    ≤h1≥这里可能是一个页面标题≤/h1≥
  ≤/header≥
  ≤main≥
    ≤p≥主要内容的一个段落。≤/p≥
    ≤p≥另一个主要段落。≤/p≥
  ≤/main≥
  ≤footer≥
    ≤p≥这里有一些联系信息≤/p≥
  ≤/footer≥
≤/div≥
```
在组合组件时，内容分发 API 是非常有用的机制。

### 作用域插槽

2.1.0 新增

作用域插槽是一种特殊类型的插槽，用作使用一个（能够传递数据到）可重用模板替换已渲染元素。
在子组件中，只需将数据传递到插槽，就像你将 prop 传递给组件一样：
```
≤div class="child"≥
  ≤slot text="hello from child"≥≤/slot≥
≤/div≥
```
在父级中，具有特殊属性 scope 的 ≤template≥ 元素，表示它是作用域插槽的模板。scope 的值对应一个临时变量名，此变量接收从子组件中传递的 prop 对象：
```
≤div class="parent"≥
  ≤child≥
    ≤template scope="props"≥
      ≤span≥hello from parent≤/span≥
      ≤span≥{{ props.text }}≤/span≥
    ≤/template≥
  ≤/child≥
≤/div≥
```
如果我们渲染以上结果，得到的输出会是：
```
≤div class="parent"≥
  ≤div class="child"≥
    ≤span≥hello from parent≤/span≥
    ≤span≥hello from child≤/span≥
  ≤/div≥
≤/div≥
```
作用域插槽更具代表性的用例是列表组件，允许组件自定义应该如何渲染列表每一项：
```
≤my-awesome-list :items="items"≥
  ≤!-- 作用域插槽也可以在这里命名 --≥
  ≤template slot="item" scope="props"≥
    ≤li class="my-fancy-item"≥{{ props.text }}≤/li≥
  ≤/template≥
≤/my-awesome-list≥
列表组件的模板：
≤ul≥
  ≤slot name="item"
    v-for="item in items"
    :text="item.text"≥
    ≤!-- fallback content here --≥
  ≤/slot≥
≤/ul≥
动态组件

通过使用保留的 ≤component≥ 元素，动态地绑定到它的 is 特性，我们让多个组件可以使用同一个挂载点，并动态切换：
var vm = new Vue({
  el: '#example',
  data: {
    currentView: 'home'
  },
  components: {
    home: { /* ... */ },
    posts: { /* ... */ },
    archive: { /* ... */ }
  }
})
≤component v-bind:is="currentView"≥
  ≤!-- 组件在 vm.currentview 变化时改变！ --≥
≤/component≥
也可以直接绑定到组件对象上：
var Home = {
  template: '≤p≥Welcome home!≤/p≥'
}
var vm = new Vue({
  el: '#example',
  data: {
    currentView: Home
  }
})
keep-alive

如果把切换出去的组件保留在内存中，可以保留它的状态或避免重新渲染。为此可以添加一个 keep-alive 指令参数：
≤keep-alive≥
  ≤component :is="currentView"≥
    ≤!-- 非活动组件将被缓存！ --≥
  ≤/component≥
≤/keep-alive≥
在API 参考查看更多 ≤keep-alive≥ 的细节。
杂项

编写可复用组件

在编写组件时，记住是否要复用组件有好处。一次性组件跟其它组件紧密耦合没关系，但是可复用组件应当定义一个清晰的公开接口。
Vue 组件的 API 来自三部分 - props, events 和 slots ：
Props 允许外部环境传递数据给组件
Events 允许组件触发外部环境的副作用
Slots 允许外部环境将额外的内容组合在组件中。
使用 v-bind 和 v-on 的简写语法，模板的缩进清楚且简洁：
≤my-component
  :foo="baz"
  :bar="qux"
  @event-a="doThis"
  @event-b="doThat"
≥
  ≤img slot="icon" src="..."≥
  ≤p slot="main-text"≥Hello!≤/p≥
≤/my-component≥
子组件索引

尽管有 props 和 events ，但是有时仍然需要在 JavaScript 中直接访问子组件。为此可以使用 ref 为子组件指定一个索引 ID 。例如：
≤div id="parent"≥
  ≤user-profile ref="profile"≥≤/user-profile≥
≤/div≥
var parent = new Vue({ el: '#parent' })
// 访问子组件
var child = parent.$refs.profile
当 ref 和 v-for 一起使用时， ref 是一个数组或对象，包含相应的子组件。
$refs 只在组件渲染完成后才填充，并且它是非响应式的。它仅仅作为一个直接访问子组件的应急方案——应当避免在模版或计算属性中使用 $refs 。

异步组件

在大型应用中，我们可能需要将应用拆分为多个小模块，按需从服务器下载。为了让事情更简单， Vue.js 允许将组件定义为一个工厂函数，动态地解析组件的定义。Vue.js 只在组件需要渲染时触发工厂函数，并且把结果缓存起来，用于后面的再次渲染。例如：
Vue.component('async-example', function (resolve, reject) {
  setTimeout(function () {
    // Pass the component definition to the resolve callback
    resolve({
      template: '≤div≥I am async!≤/div≥'
    })
  }, 1000)
})
工厂函数接收一个 resolve 回调，在收到从服务器下载的组件定义时调用。也可以调用 reject(reason) 指示加载失败。这里 setTimeout 只是为了演示。怎么获取组件完全由你决定。推荐配合使用 ：Webpack 的代码分割功能：
Vue.component('async-webpack-example', function (resolve) {
  // 这个特殊的 require 语法告诉 webpack
  // 自动将编译后的代码分割成不同的块，
  // 这些块将通过 Ajax 请求自动下载。
  require(['./my-async-component'], resolve)
})
你可以使用 Webpack 2 + ES2015 的语法返回一个 Promise resolve 函数：
Vue.component(
  'async-webpack-example',
  () =≥ System.import('./my-async-component')
)
如果你是 Browserify 用户,可能就无法使用异步组件了,它的作者已经表明 Browserify 是不支持异步加载的。Browserify 社区发现 一些解决方法，可能有助于已存在的复杂应用。对于其他场景，我们推荐简单实用 Webpack 构建，一流的异步支持

组件命名约定

当注册组件（或者 props）时，可以使用 kebab-case ，camelCase ，或 TitleCase 。Vue 不关心这个。
// 在组件定义中
components: {
  // 使用 kebab-case 形式注册
  'kebab-cased-component': { /* ... */ },
  // register using camelCase
  'camelCasedComponent': { /* ... */ },
  // register using TitleCase
  'TitleCasedComponent': { /* ... */ }
}
在 HTML 模版中，请使用 kebab-case 形式：
≤!-- 在HTML模版中始终使用 kebab-case --≥
≤kebab-cased-component≥≤/kebab-cased-component≥
≤camel-cased-component≥≤/camel-cased-component≥
≤title-cased-component≥≤/title-cased-component≥
当使用字符串模式时，可以不受 HTML 的 case-insensitive 限制。这意味实际上在模版中，你可以使用 camelCase 、 TitleCase 或者 kebab-case 来引用：
≤!-- 在字符串模版中可以用任何你喜欢的方式! --≥
≤my-component≥≤/my-component≥
≤myComponent≥≤/myComponent≥
≤MyComponent≥≤/MyComponent≥
如果组件未经 slot 元素传递内容，你甚至可以在组件名后使用 / 使其自闭合：
≤my-component/≥
当然，这只在字符串模版中有效。因为自闭的自定义元素是无效的 HTML ，浏览器原生的解析器也无法识别它。
递归组件

组件在它的模板内可以递归地调用自己，不过，只有当它有 name 选项时才可以：
name: 'unique-name-of-my-component'
当你利用Vue.component全局注册了一个组件, 全局的ID作为组件的 name 选项，被自动设置.
Vue.component('unique-name-of-my-component', {
  // ...
})
如果你不谨慎, 递归组件可能导致死循环:
name: 'stack-overflow',
template: '≤div≥≤stack-overflow≥≤/stack-overflow≥≤/div≥'
上面组件会导致一个错误 “max stack size exceeded” ，所以要确保递归调用有终止条件 (比如递归调用时使用 v-if 并让他最终返回 false )。
组件间的循环引用Circular References Between Components

假设你正在构建一个文件目录树，像在Finder或文件资源管理器中。你可能有一个 tree-folder组件:
≤p≥
  ≤span≥{{ folder.name }}≤/span≥
  ≤tree-folder-contents :children="folder.children"/≥
≤/p≥
然后 一个tree-folder-contents组件：
≤ul≥
  ≤li v-for="child in children"≥
    ≤tree-folder v-if="child.children" :folder="child"/≥
    ≤span v-else≥{{ child.name }}≤/span≥
  ≤/li≥
≤/ul≥
When you look closely, you’ll see that these components will actually be each other’s descendent and ancestor in the render tree - a paradox! When registering components globally with Vue.component, this paradox is resolved for you automatically. If that’s you, you can stop reading here.
当你仔细看时，会发现在渲染树上这两个组件同时为对方的父节点和子节点–这点是矛盾的。当使用Vue.component将这两个组件注册为全局组件的时候，框架会自动为你解决这个矛盾，如果你是这样做的，就不用继续往下看了。
然而，如果你使用诸如Webpack或者Browserify之类的模块化管理工具来requiring/importing组件的话，就会报错了：
Failed to mount component: template or render function not defined.
为了解释为什么会报错，简单的将上面两个组件称为 A 和 B ，模块系统看到它需要 A ，但是首先 A 需要 B ，但是 B 需要 A， 而 A 需要 B，陷入了一个无限循环，因此不知道到底应该先解决哪个。要解决这个问题，我们需要在其中一个组件中（比如 A ）告诉模块化管理系统，“A 虽然需要 B ，但是不需要优先导入 B”
在我们的例子中，我们选择在tree-folder 组件中来告诉模块化管理系统循环引用的组件间的处理优先级，我们知道引起矛盾的子组件是tree-folder-contents，所以我们在beforeCreate 生命周期钩子中去注册它：
beforeCreate: function () {
  this.$options.components.TreeFolderContents = require('./tree-folder-contents.vue')
}
问题解决了。
内联模版

如果子组件有 inline-template 特性，组件将把它的内容当作它的模板，而不是把它当作分发内容。这让模板更灵活。
≤my-component inline-template≥
  ≤div≥
    ≤p≥These are compiled as the component's own template.≤/p≥
    ≤p≥Not parent's transclusion content.≤/p≥
  ≤/div≥
≤/my-component≥
但是 inline-template 让模板的作用域难以理解。最佳实践是使用 template 选项在组件内定义模板或者在 .vue 文件中使用 template 元素。
X-Templates

另一种定义模版的方式是在 JavaScript 标签里使用 text/x-template 类型，并且指定一个id。例如：
≤script type="text/x-template" id="hello-world-template"≥
  ≤p≥Hello hello hello≤/p≥
≤/script≥
Vue.component('hello-world', {
  template: '#hello-world-template'
})
这在有很多模版或者小的应用中有用，否则应该避免使用，因为它将模版和组件的其他定义隔离了。
对低开销的静态组件使用 v-once

尽管在 Vue 中渲染 HTML 很快，不过当组件中包含大量静态内容时，可以考虑使用 v-once 将渲染结果缓存起来，就像这样：
Vue.component('terms-of-service', {
  template: '\
    ≤div v-once≥\
      ≤h1≥Terms of Service≤/h1≥\
      ... a lot of static content ...\
    ≤/div≥\
  '
})