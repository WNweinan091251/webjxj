# 实现一个函数，运算结果可以满足如下预期结果：
```
add(1)(2) // 3
add(1, 2, 3)(10) // 16
add(1)(2)(3)(4)(5) // 15
```
对于一个好奇的切图仔来说，忍不住动手尝试了一下，看到题目首先想到的是会用到高阶函数以及 Array.prototype.reduce()。

高阶函数(Higher-order function)：高阶函数的意思是它接收另一个函数作为参数。在 javascript 中，函数是一等公民，允许函数作为参数或者返回值传递。
得到了下面这个解法：
```
function add() {
    var args = Array.prototype.slice.call(arguments);
 
    return function() {
        var arg2 = Array.prototype.slice.call(arguments);
        return args.concat(arg2).reduce(function(a, b){
            return a + b;
        });
    }
}
```
验证了一下，发现错了：
```
add(1)(2) // 3
add(1, 2)(3) // 6
add(1)(2)(3) // Uncaught TypeError: add(...)(...) is not a function(…)
```
上面的解法，只有在 add()() 情形下是正确的。而当链式操作的参数多于两个或者少于两个的时候，无法返回结果。

而这个也是这题的一个难点所在，add()的时候，如何既返回一个值又返回一个函数以供后续继续调用？

后来经过高人指点，通过重写函数的 valueOf 方法或者 toString 方法，可以得到其中一种解法：
```
function add () {
    var args = Array.prototype.slice.call(arguments);
 
    var fn = function () {
        var arg_fn = Array.prototype.slice.call(arguments);
        return add.apply(null, args.concat(arg_fn));
    }
 
    fn.valueOf = function () {
        return args.reduce(function(a, b) {
            return a + b;
        })
    }
 
    return fn;
}
```
嗯？第一眼看到这个解法的时候，我是懵逼的。因为我感觉 fn.valueOf() 从头到尾都没有被调用过，但是验证了下结果：
```
add(1) // 1
add(1,2)(3) //6
add(1)(2)(3)(4)(5) // 15
```